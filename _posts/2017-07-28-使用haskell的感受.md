昨天在刷hackerank时碰到久违的KMP算法。这次要使用haskell来实现他。之前理解的时候一直觉得这是一个让人头疼的算法。我勉强能够使用js写出个大概，而这次更是需要使用haskell来实现。

开始的方案是先写出js版本，然后再翻译到haskell。本来晦涩的循环再加上数据不可改变的限制使得实现的复杂度成倍增加，并且写出来的代码也会无法理解。

```javascript
// (String, String) -> Bool
function kmp(str, pattern) {
  //build back array
  let back = [-1];
  let i, j;
  for(i = 1; i < pattern.length; i++) {
    let idx = back[i - 1];
    while(idx != -1 && pattern[i - 1] != pattern[idx])
      idx = back[idx];
    back[i] = idx + 1;
  }

  //main
  for(i = 0, j = 0; i < str.length, j < pattern.length; i++, j++) {
    while(str[i] != pattern[j] && j != -1)
      j = back[j];
    if(j == pattern.length - 1)
      return true;
  }
  return false;
}
```

接着，我找到了一个[递归版本](https://www.twanvl.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell)的实现方式。

```haskell
data KMP a = KMP {done :: Bool, next :: a -> KMP a}

isSubStrOf str pattern = match (makeTable pattern) str
  where
    match table [] = done table
    match table (c:str) = done table || match (next table c) str

makeTable :: Eq a => [a] -> KMP a
makeTable xs = table
  where table = makeTable' xs (const table)

makeTable' [] failure = KMP True failure
makeTable' (x:xs) failure = KMP False test
  where test c = if c == x then success else failure c
        success = makeTable' xs (next (failure x))
```

`KMP`类型代表的是一个确定有限状态机(dfa)，每一个状态会根据输入的字符跳转到成功和失败状态，`makeTable`绑定了起始状态，`makeTable'`定义了后续的状态。

这正是kmp算法的原理。在[之前的博文](/blog/2015/08/12/有限状态自动机.html)中有提到kmp就是一种dfa。并且文中还提到在js版本的kmp算法中，构造自动机代码和状态转移代码惊人相似，而haskell版本的代码通过递归抽象出了他们相似之处。

看了这个实现方式，我对haskell有了全新的认识，他不仅仅是一门语言，更是一种思维方式，让人用抽象的方式看问题，从而看清问题的本质。而在js的版本中所有的操作和跳转都是在数组内完成的，各种边界问题和跳转问题在编写时都不可避免。抽象和优化更是无从下手了。所以数据结构和算法永远是在一起的。要使用精确的数据结构来表达逻辑。
